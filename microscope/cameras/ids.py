#!/usr/bin/env python
# -*- coding: utf-8 -*-

## Copyright (C) 2019 David Miguel Susano Pinto <david.pinto@bioch.ox.ac.uk>
##
## This file is part of Microscope.
##
## Microscope is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Microscope is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Microscope.  If not, see <http://www.gnu.org/licenses/>.

"""Interface to IDS cameras.
"""

import ctypes

from typing import Tuple

from pyueye import ueye
import Pyro4

import microscope.devices

class IDSuEye(microscope.devices.CameraDevice):
    """IDS uEye camera.

    The camera ID is used to identify the camera.  Because the camera
    ID can be changed, its value can't be changed halfway through.

    Args:
        camera_id (int): the camera ID.  This is the customizable
            camera ID, not the device ID.  If zero (the default), it
            will use the first available camera which is suitable for
            systems with a single camera.

    Developer notes:

    The camera ID is a persistent and customisable value.  Using it is
    the recommended method to identify a camera by the vendor.  Its
    value can be set with the IDS Camera Manager software or with the
    private method.

    ID is not persistent and generated by the device driver upon
    connection.  The sensor ID is not a unique ID, it's the model
    number for the sensor which may be the same between multiple
    cameras.  The serial number could be a possibility.  However,
    camera ID provides an easy and convenient default value (0) for
    when there is only one camera.

    .. todo::
        IDS recommends using camera ID to identify cameras.  They
        recommend against serial number to easily swap cameras.  But
        then, on systems with multiple cameras, we have to set the
        camera ID manually which is not easy.  Seems like using the
        serial number is the least confusing.



    """
    def __init__(self, serial_number: str = None):
        super().__init__()
        ## hCam is both the camera handler and the device ID.  It's
        ## not documented them always having the same value but sure
        ## looks like it.
        self._hCam = ueye.HIDS()

        n_cameras = ctypes.c_int(0)
        if ueye.is_GetNumberOfCameras(n_cameras) != ueye.IS_SUCCESS:
            raise RuntimeError('failed to get number of cameras')
        elif not n_cameras:
            raise RuntimeError('no cameras found at all')

        if serial_number is None:
            ## If using zero as device ID for initialisation, the next
            ## available camera is picked, and enable() will set hCam
            ## with the correct device ID.
            self._hCam = ueye.HIDS(0)
        else:
            camera_list = ueye.UEYE_CAMERA_LIST()
            camera_list.dwCount = ctypes.c_uint(n_cameras.value)
            ueye.is_GetCameraList(camera_list)
            for camera in camera_list.uci:
                if camera.SerNo == serial_number.encode():
                    self._hCam = ueye.HIDS(camera.dwDeviceID.value)
                    break
            else:
                raise RuntimeError("No camera found with serial number '%s'"
                                   % serial_number)

        self.enable()
        self._sensor_shape = self._read_sensor_shape() # type: Tuple[int, int]
        self._exposure_time = self._read_exposure_time() # type: float
        self._exposure_range = self._read_exposure_range() # type: Tuple[float, float]
        self.disable()

    def _read_sensor_shape(self) -> Tuple[int, int]:
        ## Only works when camera is enabled
        sensor_info = ueye.SENSORINFO()
        status = ueye.is_GetSensorInfo(self._hCam, sensor_info)
        if status != ueye.IS_SUCCESS:
            raise RuntimeError('failed to to read the sensor information')
        return (sensor_info.nMaxWidth.value, sensor_info.nMaxHeight.value)

    def _read_exposure_time(self) -> float:
        ## Only works when camera is enabled
        time_msec = ctypes.c_double()
        status = ueye.is_Exposure(self._hCam, ueye.IS_EXPOSURE_CMD_GET_EXPOSURE,
                                  time_msec, ctypes.sizeof(time_msec))
        if status != ueye.IS_SUCCESS:
            raise RuntimeError('failed to to read exposure time')
        return (time_msec * 1000)

    def _read_exposure_range(self) -> Tuple[float, float]:
        ## Only works when camera is enabled
        range_msec = (ctypes.c_double()*3)() # min, max, inc
        status = ueye.is_Exposure(self._hCam,
                                  ueye.IS_EXPOSURE_CMD_GET_EXPOSURE_RANGE,
                                  range_msec, ctypes.sizeof(range_msec))
        if status != ueye.IS_SUCCESS:
            raise RuntimeError('failed to to read exposure time range')
        return (range_msec[0]*1000, range_msec[1]*1000)


    def initialize(self):
        pass # Already done in __init__


    def _on_enable(self) -> bool:
        ## InitCamera modifies the value of hCam.
        self._hCam = ueye.HIDS(self._hCam | ueye.IS_USE_DEVICE_ID)
        status = ueye.is_InitCamera(self._hCam, None)
        if status != ueye.IS_SUCCESS:
            raise RuntimeError('failed to init camera, returned %d' % status)
        return True

    def _on_disable(self):
        status = ueye.is_ExitCamera(self._hCam)
        if status != ueye.IS_SUCCESS:
            if status == ueye.IS_INVALID_CAMERA_HANDLE and not self.enabled:
                raise RuntimeError('failed to init camera, returned %d' % status)
        super()._on_disable()

    def _on_shutdown(self):
        if self.enabled:
            self.disable()

    ## TODO
    def abort(self):
        pass
    def _fetch_data(self):
        pass
    def set_exposure_time(self, value: float) -> None:
        pass

    def _get_sensor_shape(self) -> Tuple[int, int]:
        return self._sensor_shape


    def _get_binning(self) -> Tuple[int, int]:
        pass
    def _set_binning(self, h_bin: int, v_bin: int) -> None:
        pass
    def _get_roi(self) -> Tuple[int, int, int, int]:
        pass
    def _set_roit(self, left: int, top: int, width:int, height:int) -> None:
        pass
    def soft_trigger(self) -> None:
        pass

    # def _get_error_str(self, error_code: int):
    #     """
    #     """
    #     raise NotImplementedError('is_GetError')
    #     err_msg = ...
    #     status = ueye.is_GetError(self._hCam, ctypes.c_int(error_code), err_msg)
    #     if status == ueye.IS_SUCCESS:
    #         return err_msg.get message
    #     elif status == ueye.IS_INVALID_CAMERA_HANDLE:
    #         raise RuntimeError('Invalid camera handle')
    #     elif status == ueye.IS_INVALID_PARAMETER:
    #         raise RuntimeError('Invalid parameter: outside valid range, not'
    #                            ' supported for this sensor, or not available'
    #                            ' in current mode.')
    #     else: # IS_NO_SUCCESS or something we don't know about
    #         raise RuntimeError('Failed to retrieve error message')
